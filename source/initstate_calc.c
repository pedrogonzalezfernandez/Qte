#include "ext.h"#include "ext_obex.h"#include <stdlib.h>#include <math.h>/* -----------------------------------------------------------------------   Our object structure------------------------------------------------------------------------ */typedef struct _qte_initstatecalc {    t_object ob;    long n;         // number of eigenstates (and length of each state vector)    void *out;      // outlet pointer} t_qte_initstatecalc;/* Global class pointer */static t_class *qte_initstatecalc_class = NULL;/* Function prototypes */void *qte_initstatecalc_new(t_symbol *s, long argc, t_atom *argv);void qte_initstatecalc_free(t_qte_initstatecalc *x);void qte_initstatecalc_assist(t_qte_initstatecalc *x, void *b, long m, long a, char *s);void qte_initstatecalc_list(t_qte_initstatecalc *x, t_symbol *s, long argc, t_atom *argv);/* -----------------------------------------------------------------------   ext_main: Called by Max at load time------------------------------------------------------------------------ */void ext_main(void *r){    t_class *c;    // Rename from "initstate_calc" to "qte.initstatecalc"    c = class_new("qte.initstatecalc",                  (method)qte_initstatecalc_new,                  (method)qte_initstatecalc_free,                  sizeof(t_qte_initstatecalc),                  0L,                  A_GIMME,                  0);    class_addmethod(c, (method)qte_initstatecalc_list,   "list",   A_GIMME, 0);    class_addmethod(c, (method)qte_initstatecalc_assist, "assist", A_CANT,  0);    class_register(CLASS_BOX, c);    qte_initstatecalc_class = c; // Save the class pointer}/* -----------------------------------------------------------------------   Constructor------------------------------------------------------------------------ */void *qte_initstatecalc_new(t_symbol *s, long argc, t_atom *argv){    // Use the global pointer qte_initstatecalc_class    t_qte_initstatecalc *x = (t_qte_initstatecalc *)object_alloc(qte_initstatecalc_class);    if (x) {        x->n = 3; // default        if (argc > 0 && atom_gettype(argv) == A_LONG) {            x->n = atom_getlong(argv);        }        x->out = outlet_new(x, NULL);    }    return x;}/* -----------------------------------------------------------------------   Destructor------------------------------------------------------------------------ */void qte_initstatecalc_free(t_qte_initstatecalc *x){    // No dynamic resources to free}/* -----------------------------------------------------------------------   Assist method------------------------------------------------------------------------ */void qte_initstatecalc_assist(t_qte_initstatecalc *x, void *b, long m, long a, char *s){    if (m == 1)        sprintf(s, "Input: eigenstates & initial state vector");    else        sprintf(s, "Output: Coefficients R_k (each as a pair)");}/* -----------------------------------------------------------------------   List method: Calculate the coefficients for an initial state------------------------------------------------------------------------ */void qte_initstatecalc_list(t_qte_initstatecalc *x, t_symbol *s, long argc, t_atom *argv){    // For simplicity, assume:    // - First: n eigenstates, each with n pairs => n*n*2 numbers    // - Then: initial state vector => n*2 numbers    long n = x->n;    long eigen_count = n * n * 2;    long init_count  = n * 2;    if (argc != eigen_count + init_count) {        object_post((t_object *)x, "Expected %ld numbers", eigen_count + init_count);        return;    }    t_atom *out_list = (t_atom *)sysmem_newptr(n * 2 * sizeof(t_atom));    if (!out_list) {        object_error((t_object *)x, "Memory allocation failed");        return;    }    // For each eigenstate k, compute the Hermitian inner product with the initial state    for (long k = 0; k < n; k++) {        double re = 0, im = 0;        for (long i = 0; i < n; i++) {            double e_re = atom_getfloat(argv + (k * n * 2 + i * 2));            double e_im = atom_getfloat(argv + (k * n * 2 + i * 2 + 1));            double psi_re = atom_getfloat(argv + eigen_count + i * 2);            double psi_im = atom_getfloat(argv + eigen_count + i * 2 + 1);            // Hermitian inner product: <psi, e_k> = sum(conj(e_k[i]) * psi[i])            re += ( e_re * psi_re + e_im * psi_im );            im += ( e_re * psi_im - e_im * psi_re );        }        atom_setfloat(out_list + k * 2,     re);        atom_setfloat(out_list + k * 2 + 1, im);    }    outlet_list(x->out, gensym("list"), n * 2, out_list);    sysmem_freeptr(out_list);}