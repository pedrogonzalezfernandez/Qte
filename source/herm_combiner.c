#include "ext.h"#include "ext_obex.h"#include <stdlib.h>// Our object structure (previously herm_comb)typedef struct _qte_hermcomb {    t_object ob;    long n;    // matrix dimension    void *out; // outlet pointer} t_qte_hermcomb;// Global class pointerstatic t_class *qte_hermcomb_class = NULL;// Function prototypesvoid *qte_hermcomb_new(t_symbol *s, long argc, t_atom *argv);void qte_hermcomb_free(t_qte_hermcomb *x);void qte_hermcomb_assist(t_qte_hermcomb *x, void *b, long m, long a, char *s);void qte_hermcomb_list(t_qte_hermcomb *x, t_symbol *s, long argc, t_atom *argv);// Main entry point, called by Max at load timevoid ext_main(void *r){    t_class *c;    // Register object name as "qte.hermcombiner"    c = class_new("qte.hermcombiner",                  (method)qte_hermcomb_new,                  (method)qte_hermcomb_free,                  sizeof(t_qte_hermcomb),                  0L,                  A_GIMME,                  0);    class_addmethod(c, (method)qte_hermcomb_list,   "list",   A_GIMME, 0);    class_addmethod(c, (method)qte_hermcomb_assist, "assist", A_CANT,  0);    class_register(CLASS_BOX, c);    qte_hermcomb_class = c; // Save the class pointer}// Constructorvoid *qte_hermcomb_new(t_symbol *s, long argc, t_atom *argv){    // Use the global pointer qte_hermcomb_class    t_qte_hermcomb *x = (t_qte_hermcomb *)object_alloc(qte_hermcomb_class);    if (x) {        x->n = 3; // default dimension        if (argc > 0 && atom_gettype(argv) == A_LONG) {            x->n = atom_getlong(argv);        }        x->out = outlet_new(x, NULL);    }    return x;}// Destructorvoid qte_hermcomb_free(t_qte_hermcomb *x){    // Nothing special to free}// Assist methodvoid qte_hermcomb_assist(t_qte_hermcomb *x, void *b, long m, long a, char *s){    if (m == 1) {        sprintf(s, "Input: List of numbers for matrices & coefficients");    } else {        sprintf(s, "Output: Combined Hermitian matrix as list");    }}// List method (combines two matrices with two coefficients)void qte_hermcomb_list(t_qte_hermcomb *x, t_symbol *s, long argc, t_atom *argv){    // For demonstration, we assume two matrices each with n*n numbers,    // followed by two coefficients (total 2*n*n + 2 floats).    long n = x->n;    if (argc != 2 * n * n + 2) {        object_post((t_object *)x, "Expected %ld numbers", 2 * n * n + 2);        return;    }    double *M1 = (double *)sysmem_newptr(n * n * sizeof(double));    double *M2 = (double *)sysmem_newptr(n * n * sizeof(double));    if (!M1 || !M2) {        object_error((t_object *)x, "Memory allocation failed");        if (M1) sysmem_freeptr(M1);        if (M2) sysmem_freeptr(M2);        return;    }    // Coefficients    double c1 = atom_getfloat(argv + 2 * n * n);    double c2 = atom_getfloat(argv + 2 * n * n + 1);    // Read M1 and M2    for (long i = 0; i < n * n; i++) {        M1[i] = atom_getfloat(argv + i);        M2[i] = atom_getfloat(argv + n * n + i);    }    // Output array    t_atom *out_list = (t_atom *)sysmem_newptr(n * n * sizeof(t_atom));    if (!out_list) {        object_error((t_object *)x, "Memory allocation failed for output");        sysmem_freeptr(M1);        sysmem_freeptr(M2);        return;    }    // Combine the matrices    for (long i = 0; i < n * n; i++) {        double val = c1 * M1[i] + c2 * M2[i];        atom_setfloat(out_list + i, val);    }    outlet_list(x->out, gensym("list"), n * n, out_list);    sysmem_freeptr(out_list);    sysmem_freeptr(M1);    sysmem_freeptr(M2);}