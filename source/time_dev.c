#include "ext.h"#include "ext_obex.h"#include <math.h>#include <stdlib.h>#include <complex.h>// Our object structuretypedef struct _qte_timedev {    t_object ob;    // user data    long n;                 // dimension    double tmin;    double tmax;    long   tsteps;    double         *eigenvalues;   // array of n real    double complex *coeff;         // array of n complex    double complex **eigenstates;  // array of n, each row n complex    // outlets    void *out_magn;   // left outlet    void *out_phase;  // right outlet} t_qte_timedev;// Global class pointerstatic t_class *qte_timedev_class = NULL;// Prototypesvoid *qte_timedev_new(t_symbol *s, long argc, t_atom *argv);void  qte_timedev_free(t_qte_timedev *x);void  qte_timedev_assist(t_qte_timedev *x, void *b, long m, long a, char *s);// Message handlers: "dim", "time_settings", "set_eigenvalues", "set_coeff", "set_eigenstates", "compute"void  qte_timedev_dim(t_qte_timedev *x, t_symbol *s, long argc, t_atom *argv);void  qte_timedev_time_settings(t_qte_timedev *x, t_symbol *s, long argc, t_atom *argv);void  qte_timedev_set_eigenvalues(t_qte_timedev *x, t_symbol *s, long argc, t_atom *argv);void  qte_timedev_set_coeff(t_qte_timedev *x, t_symbol *s, long argc, t_atom *argv);void  qte_timedev_set_eigenstates(t_qte_timedev *x, t_symbol *s, long argc, t_atom *argv);void  qte_timedev_compute(t_qte_timedev *x, t_symbol *s, long argc, t_atom *argv);// The actual time evolution functionstatic void qte_timedev_do_compute(t_qte_timedev *x);// ext_mainvoid ext_main(void *r){    t_class *c = class_new("qte.timedev",                           (method)qte_timedev_new,                           (method)qte_timedev_free,                           sizeof(t_qte_timedev),                           0L, A_GIMME, 0);    // Assist method    class_addmethod(c, (method)qte_timedev_assist, "assist", A_CANT, 0);    // Our custom messages on the single inlet    class_addmethod(c, (method)qte_timedev_dim,           "dim",           A_GIMME, 0);    class_addmethod(c, (method)qte_timedev_time_settings, "time_settings", A_GIMME, 0);    class_addmethod(c, (method)qte_timedev_set_eigenvalues, "set_eigenvalues", A_GIMME, 0);    class_addmethod(c, (method)qte_timedev_set_coeff,       "set_coeff",      A_GIMME, 0);    class_addmethod(c, (method)qte_timedev_set_eigenstates, "set_eigenstates",A_GIMME, 0);    // Final "compute" message triggers the output    class_addmethod(c, (method)qte_timedev_compute,       "compute",       A_GIMME, 0);    class_register(CLASS_BOX, c);    qte_timedev_class = c;}// Constructorvoid *qte_timedev_new(t_symbol *s, long argc, t_atom *argv){    t_qte_timedev *x = (t_qte_timedev*)object_alloc(qte_timedev_class);    if (!x) return NULL;    // defaults    x->n      = 4;    x->tmin   = 0.0;    x->tmax   = 5.0;    x->tsteps = 20;    x->eigenvalues  = NULL;    x->coeff        = NULL;    x->eigenstates  = NULL;    // single inlet => automatically created as leftmost    // we don't need inlet_new for the default inlet    // two outlets    x->out_magn  = outlet_new((t_object*)x, NULL);    x->out_phase = outlet_new((t_object*)x, NULL);    return (x);}// Destructorvoid qte_timedev_free(t_qte_timedev *x){    if (x->eigenstates) {        for (long k=0; k<x->n; k++) {            free(x->eigenstates[k]);        }        free(x->eigenstates);    }    if (x->eigenvalues) {        free(x->eigenvalues);    }    if (x->coeff) {        free(x->coeff);    }}// Assist methodvoid qte_timedev_assist(t_qte_timedev *x, void *b, long m, long a, char *s){    if (m==1) {        sprintf(s, "Messages: dim <n>, time_settings <tmin> <tmax> <tsteps>, set_eigenvalues, set_coeff, set_eigenstates, compute");    } else {        switch(a) {            case 0: sprintf(s, "Phases"); break;            case 1: sprintf(s, "Magnitudes"); break;        }    }}/* ------------------------------------------------------------------   1) dim <n>------------------------------------------------------------------ */void qte_timedev_dim(t_qte_timedev *x, t_symbol *s, long argc, t_atom *argv){    if (argc >= 1) {        long tmp = atom_getlong(argv);        if (tmp > 0) {            x->n = tmp;            // you might want to free old data if dimension changes            if (x->eigenstates) {                for (long k=0; k<x->n; k++) {                    free(x->eigenstates[k]);                }                free(x->eigenstates);                x->eigenstates = NULL;            }            if (x->eigenvalues) { free(x->eigenvalues); x->eigenvalues=NULL; }            if (x->coeff) { free(x->coeff); x->coeff=NULL; }            object_post((t_object*)x, "dimension set to %ld", x->n);        }    }}/* ------------------------------------------------------------------   2) time_settings <tmin> <tmax> <tsteps>------------------------------------------------------------------ */void qte_timedev_time_settings(t_qte_timedev *x, t_symbol *s, long argc, t_atom *argv){    if (argc < 3) {        object_error((t_object*)x, "time_settings needs 3 arguments: tmin tmax tsteps");        return;    }    x->tmin   = atom_getfloat(argv);    x->tmax   = atom_getfloat(argv+1);    x->tsteps = atom_getlong(argv+2);    if (x->tsteps < 2) x->tsteps=2;    object_post((t_object*)x, "time_settings: tmin=%.2f, tmax=%.2f, tsteps=%ld", x->tmin, x->tmax, x->tsteps);}/* ------------------------------------------------------------------   3) set_eigenvalues <n floats>------------------------------------------------------------------ */void qte_timedev_set_eigenvalues(t_qte_timedev *x, t_symbol *s, long argc, t_atom *argv){    if (argc != x->n) {        object_error((t_object*)x, "Expected %ld floats for eigenvalues", x->n);        return;    }    if (!x->eigenvalues) {        x->eigenvalues = (double*)malloc(x->n * sizeof(double));    }    for (long i=0; i<x->n; i++) {        x->eigenvalues[i] = atom_getfloat(argv + i);    }    object_post((t_object*)x, "Eigenvalues set");}/* ------------------------------------------------------------------   4) set_coeff <2*n floats> => n complex------------------------------------------------------------------ */void qte_timedev_set_coeff(t_qte_timedev *x, t_symbol *s, long argc, t_atom *argv){    if (argc != 2*x->n) {        object_error((t_object*)x, "Expected 2*%ld=%ld floats for init coeff", x->n, 2*x->n);        return;    }    if (!x->coeff) {        x->coeff = (double complex*)malloc(x->n*sizeof(double complex));    }    for (long i=0; i<x->n; i++) {        double re = atom_getfloat(argv + 2*i);        double im = atom_getfloat(argv + 2*i + 1);        x->coeff[i] = re + im*I;    }    object_post((t_object*)x, "Coefficients set");}/* ------------------------------------------------------------------   5) set_eigenstates <2*n*n floats>------------------------------------------------------------------ */void qte_timedev_set_eigenstates(t_qte_timedev *x, t_symbol *s, long argc, t_atom *argv){    long n = x->n;    if (argc != 2*n*n) {        object_error((t_object*)x, "Expected 2*n*n=%ld floats for eigenstates", 2*n*n);        return;    }    if (!x->eigenstates) {        x->eigenstates = (double complex**)malloc(n*sizeof(double complex*));        for (long k=0; k<n; k++) {            x->eigenstates[k] = (double complex*)malloc(n*sizeof(double complex));        }    }    // We'll interpret them in row-major: for k=0..(n-1), for i=0..(n-1) => index=2*(k*n + i)    for (long k=0; k<n; k++) {        for (long i=0; i<n; i++) {            long idx = 2*(k*n + i);            double re = atom_getfloat(argv + idx);            double im = atom_getfloat(argv + idx + 1);            x->eigenstates[k][i] = re + im*I;        }    }    object_post((t_object*)x, "Eigenstates set");}/* ------------------------------------------------------------------   6) compute => do the time evolution & output------------------------------------------------------------------ */void qte_timedev_compute(t_qte_timedev *x, t_symbol *s, long argc, t_atom *argv){    // check everything    if (!x->eigenvalues || !x->coeff || !x->eigenstates) {        object_error((t_object*)x, "Need eigenvalues, coeff, eigenstates first");        return;    }    // do it    qte_timedev_do_compute(x);}/* ------------------------------------------------------------------   The actual time evolution------------------------------------------------------------------ */static void qte_timedev_do_compute(t_qte_timedev *x){    long n = x->n;    if (n<=0) return;    long tsteps = x->tsteps;    if (tsteps<2) tsteps=2;    double dt = (x->tmax - x->tmin)/(tsteps-1);    // We'll produce for each "track" i in [0..n-1] lines for magn & phase    for (long i=0; i<n; i++) {        // 1 + 2*tsteps items => track index, then pairs (time, value)        t_atom *mag_line   = (t_atom*)sysmem_newptr((1 + 2*tsteps)*sizeof(t_atom));        t_atom *phase_line = (t_atom*)sysmem_newptr((1 + 2*tsteps)*sizeof(t_atom));        if (!mag_line || !phase_line) {            if (mag_line) sysmem_freeptr(mag_line);            if (phase_line) sysmem_freeptr(phase_line);            object_error((t_object*)x, "Memory allocation failed for output lines");            return;        }        // First item => i        atom_setlong(mag_line, i);        atom_setlong(phase_line, i);        // compute for each time step        for (long t=0; t<tsteps; t++){            double time = x->tmin + t*dt;            double complex accum = 0.0 + 0.0*I;            // \Psi(i, time) = sum_k [coeff[k]* e^{- i eigenvalues[k]*time} * eigenstates[k][i]]            for (long k=0; k<n; k++){                double ev = x->eigenvalues[k];                double complex factor = cexp(-I * ev * time);                accum += x->coeff[k]*factor*x->eigenstates[k][i];            }            double mag   = cabs(accum);            double phase = carg(accum);            long idx = 1 + 2*t;            atom_setfloat(mag_line   + idx,   time);            atom_setfloat(mag_line   + idx+1, mag);            atom_setfloat(phase_line + idx,   time);            atom_setfloat(phase_line + idx+1, phase);        }        // Output        outlet_list(x->out_magn,  gensym("list"), (1 + 2*tsteps), mag_line);        outlet_list(x->out_phase, gensym("list"), (1 + 2*tsteps), phase_line);        sysmem_freeptr(mag_line);        sysmem_freeptr(phase_line);    }    object_post((t_object*)x, "Time development done.");}