/* qte.hermitmaker.c – Hermitian Matrix Maker external for Max/MSP * * This external takes an input list representing an upper–triangular matrix * (n×n, provided in row–major order; the entries below the diagonal are assumed * to be zero and the diagonal entries are real) and outputs the full Hermitian matrix. * * The computation is: *   For i == j: *      H[i][j] = 2 * U[i][j] *   For i != j: *      H[i][j] = U[i][j] + U[j][i] * * The output is sent as a flat list. * * Compile with Xcode using the Max SDK. */#include "ext.h"#include "ext_obex.h"#include <stdlib.h>#include <stdio.h>/* ------------------------------------------------------------   Our object structure   ------------------------------------------------------------ */typedef struct _qte_hermitmaker {    t_object ob;    long n;        // Matrix dimension    void *out;     // Outlet pointer} t_qte_hermitmaker;/* Global class pointer */static t_class *qte_hermitmaker_class = NULL;/* Function prototypes */void *qte_hermitmaker_new(t_symbol *s, long argc, t_atom *argv);void qte_hermitmaker_free(t_qte_hermitmaker *x);void qte_hermitmaker_assist(t_qte_hermitmaker *x, void *b, long m, long a, char *s);void qte_hermitmaker_list(t_qte_hermitmaker *x, t_symbol *s, long argc, t_atom *argv);/* -------------------------------------------------------------------   Main entry point, called by Max at load time   ------------------------------------------------------------------- */void ext_main(void *r){    t_class *c = class_new("qte.hermitmaker",                       // name in Max                           (method)qte_hermitmaker_new,                           (method)qte_hermitmaker_free,                           sizeof(t_qte_hermitmaker),                           0L,                           A_GIMME,                           0);    class_addmethod(c, (method)qte_hermitmaker_list,   "list",   A_GIMME, 0);    class_addmethod(c, (method)qte_hermitmaker_assist, "assist", A_CANT,  0);    class_register(CLASS_BOX, c);    qte_hermitmaker_class = c;  // Save the class pointer}/* -------------------------------------------------------------------   Create a new instance of the object   ------------------------------------------------------------------- */void *qte_hermitmaker_new(t_symbol *s, long argc, t_atom *argv){    t_qte_hermitmaker *x = (t_qte_hermitmaker *)object_alloc(qte_hermitmaker_class);    if (x) {        // Default matrix dimension        x->n = 3;        if (argc > 0) {            if (atom_gettype(argv) == A_LONG)                x->n = atom_getlong(argv);            else if (atom_gettype(argv) == A_FLOAT)                x->n = (long)atom_getfloat(argv);        }        if (x->n <= 0)            x->n = 3;        // Create an outlet        x->out = outlet_new(x, NULL);    }    return x;}/* -------------------------------------------------------------------   Free the object (nothing to free in this simple example)   ------------------------------------------------------------------- */void qte_hermitmaker_free(t_qte_hermitmaker *x){    // No dynamic memory allocated}/* -------------------------------------------------------------------   Provide assistance messages for inlets/outlets   ------------------------------------------------------------------- */void qte_hermitmaker_assist(t_qte_hermitmaker *x, void *b, long m, long a, char *s){    if (m == 1) {        sprintf(s, "Input: List representing an upper-triangular matrix (%ld numbers)", x->n * x->n);    } else {        sprintf(s, "Output: Hermitian matrix as flat list (%ld numbers)", x->n * x->n);    }}/* -------------------------------------------------------------------   Process the input list message and output the Hermitian matrix   ------------------------------------------------------------------- */void qte_hermitmaker_list(t_qte_hermitmaker *x, t_symbol *s, long argc, t_atom *argv){    long n = x->n;    long total = n * n;    if (argc != total) {        object_post((t_object *)x, "Expected %ld numbers, received %ld", total, argc);        return;    }    // Allocate an output array for the Hermitian matrix    t_atom *out_list = (t_atom *)sysmem_newptr(total * sizeof(t_atom));    if (!out_list) {        object_error((t_object *)x, "Memory allocation failed");        return;    }    // For i == j: H[i][i] = 2 * U[i][i].    // For i != j: H[i][j] = U[i][j] + U[j][i].    for (long i = 0; i < n; i++) {        for (long j = 0; j < n; j++) {            long index = i * n + j;            double val;            if (i == j) {                val = 2.0 * atom_getfloat(argv + index);            } else {                double v1 = atom_getfloat(argv + index);                double v2 = atom_getfloat(argv + (j * n + i));                val = v1 + v2;            }            atom_setfloat(out_list + index, val);        }    }    // Output the resulting Hermitian matrix    outlet_list(x->out, gensym("list"), total, out_list);    sysmem_freeptr(out_list);}