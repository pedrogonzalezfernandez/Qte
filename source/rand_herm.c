#include "ext.h"#include "ext_obex.h"#include <stdlib.h>////////////////////////////////////////////////////////////////////////////////// Our object structure////////////////////////////////////////////////////////////////////////////////typedef struct _qte_randherm {    t_object ob;    long n;        // matrix dimension    void *out;     // outlet pointer} t_qte_randherm;////////////////////////////////////////////////////////////////////////////////// Global class pointer////////////////////////////////////////////////////////////////////////////////static t_class *qte_randherm_class = NULL;////////////////////////////////////////////////////////////////////////////////// Function prototypes////////////////////////////////////////////////////////////////////////////////void *qte_randherm_new(t_symbol *s, long argc, t_atom *argv);void qte_randherm_free(t_qte_randherm *x);void qte_randherm_assist(t_qte_randherm *x, void *b, long m, long a, char *s);void qte_randherm_bang(t_qte_randherm *x);////////////////////////////////////////////////////////////////////////////////// ext_main: Called by Max at load time////////////////////////////////////////////////////////////////////////////////void ext_main(void *r){    t_class *c;    // Name our object "qte.randherm"    c = class_new("qte.randherm",                  (method)qte_randherm_new,                  (method)qte_randherm_free,                  sizeof(t_qte_randherm),                  0L,                  A_GIMME,                  0);        class_addmethod(c, (method)qte_randherm_bang,   "bang",   0);    class_addmethod(c, (method)qte_randherm_assist, "assist", A_CANT, 0);        class_register(CLASS_BOX, c);    qte_randherm_class = c; // Save the class pointer}////////////////////////////////////////////////////////////////////////////////// Constructor////////////////////////////////////////////////////////////////////////////////void *qte_randherm_new(t_symbol *s, long argc, t_atom *argv){    // Use the global pointer qte_randherm_class    t_qte_randherm *x = (t_qte_randherm *)object_alloc(qte_randherm_class);    if (x) {        x->n = 3; // default dimension        if (argc > 0 && atom_gettype(argv) == A_LONG)            x->n = atom_getlong(argv);                x->out = outlet_new(x, NULL);    }    return x;}////////////////////////////////////////////////////////////////////////////////// Destructor////////////////////////////////////////////////////////////////////////////////void qte_randherm_free(t_qte_randherm *x){    // Nothing special to free}////////////////////////////////////////////////////////////////////////////////// Assistance method////////////////////////////////////////////////////////////////////////////////void qte_randherm_assist(t_qte_randherm *x, void *b, long m, long a, char *s){    if (m == 1) {        sprintf(s, "Bang to generate a random Hermitian matrix");    } else {        sprintf(s, "Output: Hermitian matrix as flat list");    }}////////////////////////////////////////////////////////////////////////////////// Bang method: Generate & output a random Hermitian matrix////////////////////////////////////////////////////////////////////////////////void qte_randherm_bang(t_qte_randherm *x){    long n = x->n;    t_atom *out_list = (t_atom *)sysmem_newptr(n * n * sizeof(t_atom));    double *mat = (double *)sysmem_newptr(n * n * sizeof(double));        if (!out_list || !mat) {        object_error((t_object *)x, "Memory allocation failed");        if (out_list) sysmem_freeptr(out_list);        if (mat) sysmem_freeptr(mat);        return;    }    // Fill upper triangle with random numbers    for (long i = 0; i < n; i++) {        for (long j = 0; j < n; j++) {            if (i <= j)                mat[i*n + j] = ((double)rand() / (double)RAND_MAX);            else                mat[i*n + j] = 0; // lower triangle will be set by symmetry        }    }    // Form Hermitian matrix: for diagonal, H[i][i] = 2 * U[i][i]; for i<j, sum them.    for (long i = 0; i < n; i++) {        for (long j = 0; j < n; j++) {            double val;            if (i == j) {                val = 2.0 * mat[i*n + j];            } else if (i < j) {                val = mat[i*n + j] + mat[j*n + i];            } else {                val = 0; // for the lower triangle, or you can apply symmetry if needed            }            atom_setfloat(out_list + (i*n + j), val);        }    }    outlet_list(x->out, gensym("list"), n*n, out_list);        sysmem_freeptr(out_list);    sysmem_freeptr(mat);}